package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"study-gator-backend/graph/gqlcontext"
	"study-gator-backend/graph/model"

	"gorm.io/gorm"
)

// AddFriend is the resolver for the addFriend field.
func (r *mutationResolver) AddFriend(ctx context.Context, id string) (*model.User, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var target model.User
	tx := model.DB.First(&target, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	var fr model.FriendRequest
	fr.SenderID = int(me.ID)
	fr.ReceiverID = int(target.ID)
	fr.Accepted = false
	tx = model.DB.Create(&fr)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &target, nil
}

// AcceptFriendRequest is the resolver for the acceptFriendRequest field.
func (r *mutationResolver) AcceptFriendRequest(ctx context.Context, id string) (*model.FriendRequest, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var fr model.FriendRequest
	tx := model.DB.First(&fr, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if fr.ReceiverID != int(me.ID) {
		return nil, fmt.Errorf("invalid friend request")
	}

	fr.Accepted = true

	tx = model.DB.Save(&fr)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &fr, nil
}

// DeclineFriendRequest is the resolver for the declineFriendRequest field.
func (r *mutationResolver) DeclineFriendRequest(ctx context.Context, id string) (*model.FriendRequest, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var fr model.FriendRequest
	tx := model.DB.First(&fr, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if fr.ReceiverID != int(me.ID) {
		return nil, fmt.Errorf("invalid friend request")
	}

	tx = model.DB.Delete(&fr)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &fr, nil
}

// RevokeOutgoingFriendRequest is the resolver for the revokeOutgoingFriendRequest field.
func (r *mutationResolver) RevokeOutgoingFriendRequest(ctx context.Context, id string) (*model.FriendRequest, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var fr model.FriendRequest
	tx := model.DB.First(&fr, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if fr.SenderID != int(me.ID) {
		return nil, fmt.Errorf("invalid friend request")
	}

	tx = model.DB.Delete(&fr)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &fr, nil
}

// CreateDm is the resolver for the createDM field.
func (r *mutationResolver) CreateDm(ctx context.Context, ids []string, name *string) (*model.DirectMessage, error) {
	if len(ids) > 8 {
		return nil, fmt.Errorf("cannot have more than 8 people in a group")
	}

	_, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var dm model.DirectMessage
	if name == nil {
		dm.Name = ""
	} else {
		dm.Name = *name
	}

	err = model.DB.Transaction(func(db *gorm.DB) error {
		tx := db.Create(&dm)
		if tx.Error != nil {
			return tx.Error
		}

		for _, userID := range ids {
			var dmm model.DirectMessageMember
			dmm.UserID = int(model.StringIDToIntID(userID))
			dmm.DirectMessageID = int(dm.ID)
			tx = db.Create(&dm)
			if tx.Error != nil {
				return tx.Error
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return &dm, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, id string, content string) (*model.DirectMessagePost, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var dmm []model.DirectMessageMember
	tx := model.DB.Find(&dmm, "user_id = ?", model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if len(dmm) < 1 {
		return nil, fmt.Errorf("invalid request")
	}

	var dmp model.DirectMessagePost
	dmp.Content = content
	dmp.DirectMessageID = int(model.StringIDToIntID(id))
	dmp.UserID = int(me.ID)

	tx = model.DB.Create(&dmp)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &dmp, nil
}

// CreateStudyGroup is the resolver for the createStudyGroup field.
func (r *mutationResolver) CreateStudyGroup(ctx context.Context, classID string, name string, description string) (*model.StudyGroup, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var studyGroup model.StudyGroup
	studyGroup.ClassID = int(model.StringIDToIntID(classID))
	studyGroup.Name = name
	studyGroup.Description = description
	studyGroup.OwnerID = int(me.ID)

	tx := model.DB.Create(&studyGroup)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &studyGroup, nil
}

// UpdateStudyGroup is the resolver for the updateStudyGroup field.
func (r *mutationResolver) UpdateStudyGroup(ctx context.Context, id string, classID string, name string, description string, favorite bool) (*model.StudyGroup, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var studyGroup model.StudyGroup

	tx := model.DB.First(&studyGroup, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if studyGroup.OwnerID != int(me.ID) {
		return nil, fmt.Errorf("invalid request")
	}

	studyGroup.ClassID = int(model.StringIDToIntID(classID))
	studyGroup.Name = name
	studyGroup.Description = description

	tx = model.DB.Save(&studyGroup)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &studyGroup, nil
}

// DeleteStudyGroup is the resolver for the deleteStudyGroup field.
func (r *mutationResolver) DeleteStudyGroup(ctx context.Context, id string) (*model.StudyGroup, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var studyGroup model.StudyGroup

	tx := model.DB.First(&studyGroup, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if studyGroup.OwnerID != int(me.ID) {
		return nil, fmt.Errorf("invalid request")
	}

	tx = model.DB.Delete(&studyGroup)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &studyGroup, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, studyGroupID string, name string, content string, uploads []*model.UploadWithMeta) (*model.Post, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var studyGroup model.StudyGroup
	tx := model.DB.First(&studyGroup, model.StringIDToIntID(studyGroupID))
	if tx.Error != nil {
		return nil, tx.Error
	}

	var sgm []model.StudyGroupMember
	tx = model.DB.Find(&sgm, "user_id = ?", me.ID)
	if tx.Error != nil {
		return nil, tx.Error
	}

	if len(sgm) < 1 {
		return nil, fmt.Errorf("invalid request")
	}

	var post model.Post
	post.StudyGroupID = int(model.StringIDToIntID(studyGroupID))
	post.Name = name
	post.Content = content
	post.PosterID = int(me.ID)

	// Using a transaction to rollback DB operations in case of failure.
	err = model.DB.Transaction(func(db *gorm.DB) error {
		tx = db.Create(&studyGroup)
		if tx.Error != nil {
			return tx.Error
		}

		for _, upload := range uploads {
			var attach model.PostAttachment
			attach.FileName = upload.Filename
			if upload.Description != nil {
				attach.Description = *upload.Description
			} else {
				attach.Description = ""
			}
			tx = db.Create(&attach)
			if tx.Error != nil {
				return tx.Error
			}

			file, err := os.Create(fmt.Sprintf("uploads/%d", attach.ID))
			if err != nil {
				return err
			}
			_, err = io.Copy(file, upload.Upload.File)
			if err != nil {
				return err
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return &post, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, name string, content string) (*model.Post, error) {
	_, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var post model.Post
	tx := model.DB.First(&post, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}
	post.Name = name
	post.Content = content

	tx = model.DB.Save(&post)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (*model.Post, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var post model.Post
	tx := model.DB.First(&post, model.StringIDToIntID(id))
	if tx.Error != nil {
		return nil, tx.Error
	}

	if post.PosterID != int(me.ID) {
		return nil, fmt.Errorf("invalid request")
	}

	tx = model.DB.Delete(&post)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return &post, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, term string) ([]*model.SearchResult, error) {
	// TODO: Search
	panic("todo")
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, limit int, offset int) ([]*model.Post, error) {
	if limit > 20 {
		return nil, fmt.Errorf("invalid limit")
	}
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var posts []*model.Post
	tx := model.DB.Limit(limit).Offset(offset).Joins("StudyGroupMember", model.DB.Where(&model.StudyGroupMember{UserID: int(me.ID)})).Joins("StudyGroup").Order("updated_at desc").Find(&posts)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return posts, nil
}

// Classes is the resolver for the classes field.
func (r *queryResolver) Classes(ctx context.Context) ([]*model.Class, error) {
	var classes []*model.Class
	tx := model.DB.Find(&classes)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return classes, nil
}

// StudyGroups is the resolver for the studyGroups field.
func (r *queryResolver) StudyGroups(ctx context.Context, onlyFavorites bool) ([]*model.StudyGroup, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var studyGroups []*model.StudyGroup
	if onlyFavorites {
		tx := model.DB.Joins("JOIN study_group_members ON study_group_members.study_group_id = study_groups.id AND study_group_members.user_id = ?", me.ID).Find(&studyGroups, "favorite = ?", true)
		if !errors.Is(tx.Error, gorm.ErrRecordNotFound) && tx.Error != nil {
			return nil, tx.Error
		}
	} else {
		tx := model.DB.Joins("JOIN study_group_members ON study_group_members.study_group_id = study_groups.id AND study_group_members.user_id = ?", me.ID).Find(&studyGroups)
		if !errors.Is(tx.Error, gorm.ErrRecordNotFound) && tx.Error != nil {
			return nil, tx.Error
		}
	}

	var ownStudyGroups []*model.StudyGroup
	tx := model.DB.Find(&ownStudyGroups, "owner_id = ?", me.ID)
	if !errors.Is(tx.Error, gorm.ErrRecordNotFound) && tx.Error != nil {
		return nil, tx.Error
	}

	var studyGroupPointers []*model.StudyGroup
	for _, studyGroup := range ownStudyGroups {
		studyGroupPointers = append(studyGroupPointers, studyGroup)
	}
	for _, studyGroup := range studyGroups {
		studyGroupPointers = append(studyGroupPointers, studyGroup)
	}

	return studyGroupPointers, nil
}

// Dms is the resolver for the dms field.
func (r *queryResolver) Dms(ctx context.Context) ([]*model.DirectMessage, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var dms []*model.DirectMessage
	tx := model.DB.Joins("DirectMessageMember", model.DB.Where(&model.DirectMessageMember{UserID: int(me.ID)})).Find(&dms)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return dms, nil
}

// FriendRequests is the resolver for the friendRequests field.
func (r *queryResolver) FriendRequests(ctx context.Context) ([]*model.FriendRequest, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var frs []*model.FriendRequest
	tx := model.DB.Find(&frs, "receiver_id = ?", me.ID)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return frs, nil
}

// Friends is the resolver for the friends field.
func (r *queryResolver) Friends(ctx context.Context) ([]*model.User, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var users []*model.User
	tx := model.DB.Joins("JOIN friend_requests ON friend_requests.sender_id = users.id OR friend_requests.receiver_id = users.id", me.ID, me.ID).Find(&users, "id = ?", me.ID)
	if tx.Error != nil {
		return nil, tx.Error
	}

	return users, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	me, err := gqlcontext.UserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	return me, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
